{
  "rules": [
    {
      "type": "prd",
      "content": "## 1. Introduction\n\nThis document outlines the product requirements for a desktop application that serves as a competitive platform for PlayerUnknown's Battlegrounds (PUBG) players. The platform will leverage PUBG game data to facilitate competition among users through various mini-games and challenges.\n\n## 2. Goals\n\n*   Provide a fair and competitive environment for PUBG players.\n*   Offer a unique and engaging experience based on PUBG game data.\n*   Foster a sense of community among players.\n*   Address concerns regarding data security and cheating.\n*   Provide a localized experience for Korean users.\n\n## 3. Target Audience\n\n*   General individual users who play PUBG.\n*   Korean PUBG players seeking a competitive platform.\n\n## 4. Features\n\n### 4.1 Core Features\n\n*   **User Authentication and Account Management:** Secure user registration, login, and profile management.\n*   **Customizable Dashboard:** Users can personalize their dashboard to display relevant information and statistics.\n*   **Real-time Notifications:** Users receive updates on challenges, rankings, and other relevant events.\n*   **Dark Mode Support:** Option for a dark mode to reduce eye strain.\n*   **Advanced Role Management:** Differentiated access based on user roles (e.g., admin, moderator, player).\n*   **Room Creation/Participation:** Users can create or join rooms to compete in mini-games.\n*   **Game Data-Driven Competition:** The platform utilizes PUBG game data (e.g., kills, assists, survival time) to drive competition and scoring.\n\n### 4.2 Key Features\n\n*   **Mini-Game Implementation:**\n    *   **Kill Race:** Players compete to get the most kills in a set amount of time.\n    *   **Survival Challenge:** Players compete to survive the longest.\n    *   **Accuracy Test:** Players compete based on their accuracy stats.\n*   **Ranking System:** A comprehensive ranking system based on player performance in mini-games.\n*   **Leaderboards:** Display top-performing players in various categories.\n*   **Matchmaking:** Skill-based matchmaking to ensure fair competition.\n*   **Anti-Cheat Measures:** Robust anti-cheat system to prevent cheating and maintain fair play.\n*   **PUBG API Integration:** Seamless integration with the PUBG API to retrieve game data.\n*   **Korean Language Support:** Full localization for Korean users.\n\n## 5. Use Cases\n\n*   A player logs in and creates a profile.\n*   A player joins a room to participate in a kill race.\n*   The platform retrieves game data from the PUBG API.\n*   The platform calculates scores based on the game data.\n*   The platform updates the leaderboard.\n*   A player receives a notification when a new challenge is available.\n*   A player customizes their dashboard to display their kill/death ratio.\n\n## 6. Problem Statement\n\n*   Lack of localized competitive platforms for Korean PUBG players.\n*   Concerns about data security and privacy.\n*   Prevalence of cheating in online games.\n*   Unfair matchmaking systems.\n*   Difficulty in accessing and utilizing PUBG game data for competitive purposes.\n\n## 7. Proposed Solution\n\n*   Develop a desktop application that provides a competitive platform for PUBG players.\n*   Implement robust data security measures to protect user data.\n*   Integrate a powerful anti-cheat system to prevent cheating.\n*   Utilize skill-based matchmaking to ensure fair competition.\n*   Provide a user-friendly interface with Korean language support.\n*   Leverage the PUBG API to retrieve game data and create engaging mini-games.\n\n## 8. Release Criteria\n\n*   All core features are fully functional.\n*   The platform is stable and reliable.\n*   The anti-cheat system is effective.\n*   The matchmaking system is fair.\n*   The user interface is intuitive and user-friendly.\n*   The platform is localized for Korean users.\n\n## 9. Future Considerations\n\n*   Integration with other games.\n*   Implementation of a reward system.\n*   Expansion of mini-game offerings.\n*   Mobile app development.\n\n## 10. Metrics\n\n*   Number of registered users.\n*   Number of active users.\n*   Number of games played.\n*   Average game session duration.\n*   User satisfaction (e.g., through surveys).\n*   Retention rate.\n\n## 11. Dependencies\n\n*   PUBG API.\n*   Electron framework.\n*   Vite build tool.\n*   ShadcnUI component library.\n*   Supabase backend platform.",
      "writedAt": "2026-01-06T05:10:30.097Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**: PUBG 플레이어들을 위한 경쟁 플랫폼을 제공하는 데스크톱 애플리케이션을 개발합니다. 이 플랫폼은 PUBG 게임 데이터를 활용하여 다양한 미니 게임 및 챌린지를 통해 사용자 간의 경쟁을 촉진합니다. Electron, TypeScript, React, Tailwind CSS, Shadcn UI, Supabase, Supabase Auth, Supabase Realtime을 사용하여 빠르고 안정적인 개발을 목표로 합니다.\n- **핵심 기술 스택**: Electron, TypeScript, React, Tailwind CSS, Shadcn UI, Supabase, Supabase Auth, Supabase Realtime\n- **주요 기술 목표**:\n    - 성능: 빠른 응답 시간 및 효율적인 리소스 사용\n    - 확장성: 증가하는 사용자 및 데이터 양에 대한 대응\n    - 안정성: 안정적인 서비스 운영 및 오류 최소화\n- **주요 기술 가정**:\n    - PUBG API의 안정적인 데이터 제공\n    - Electron 환경에서의 데스크톱 애플리케이션 개발의 용이성\n    - Supabase의 안정적인 백엔드 서비스 제공\n\n## 2. Tech Stack\n\n| 카테고리         | 기술 / 라이브러리             | 사유 (이 프로젝트에 선택된 이유)                                                                                                                                                                                                                 |\n| -------------- | --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 플랫폼         | Electron                      | 크로스 플랫폼 데스크톱 애플리케이션 개발을 위한 최적의 선택. 웹 기술(HTML, CSS, JavaScript)을 사용하여 개발 가능하며, 네이티브 애플리케이션과 유사한 성능과 기능을 제공합니다.                                                                                                             |\n| 언어           | TypeScript                    | JavaScript의 슈퍼셋으로, 정적 타입 검사를 통해 코드의 안정성을 높이고 유지보수를 용이하게 합니다. 대규모 프로젝트에 적합하며, 개발 생산성을 향상시킵니다.                                                                                                                            |\n| UI 프레임워크    | React                         | 컴포넌트 기반 아키텍처를 통해 UI 개발을 효율적으로 수행할 수 있습니다. 가상 DOM을 사용하여 성능을 최적화하고, 다양한 라이브러리 및 도구와의 통합이 용이합니다.                                                                                                                             |\n| 스타일링        | Tailwind CSS                  | 유틸리티 기반 CSS 프레임워크로, 빠른 UI 개발과 일관된 디자인 시스템 구축을 지원합니다. 컴포넌트 재사용성을 높이고, 스타일 충돌 문제를 방지합니다.                                                                                                                                   |\n| UI 컴포넌트 라이브러리 | Shadcn UI                     | 재사용 가능한 UI 컴포넌트 세트를 제공하여 개발 속도를 높이고 일관된 사용자 경험을 제공합니다. Tailwind CSS와 호환되어 스타일링을 쉽게 커스터마이징할 수 있습니다.                                                                                                                             |\n| 백엔드          | Supabase                      | BaaS(Backend as a Service) 플랫폼으로, 인증, 데이터베이스, 실시간 통신 등 다양한 백엔드 기능을 제공합니다. 서버리스 아키텍처를 통해 인프라 관리를 최소화하고 개발에 집중할 수 있습니다.                                                                                                                    |\n| 인증           | Supabase Auth               | 안전하고 간편한 사용자 인증 및 권한 관리를 제공합니다. 소셜 로그인, 이메일/비밀번호 로그인 등 다양한 인증 방식을 지원하며, JWT(JSON Web Token)를 사용하여 사용자 세션을 관리합니다.                                                                                                                 |\n| 실시간 통신      | Supabase Realtime             | WebSocket을 기반으로 실시간 데이터 업데이트 및 푸시 알림을 지원합니다. 게임 데이터, 랭킹 업데이트, 알림 등 실시간으로 변경되는 정보를 사용자에게 빠르게 전달할 수 있습니다.                                                                                                                          |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Electron Application (Frontend)**:\n    - 사용자 인터페이스 (UI) 및 사용자 경험 (UX) 제공\n    - React 컴포넌트 기반으로 구축\n    - Tailwind CSS 및 Shadcn UI를 사용하여 스타일링 및 레이아웃 구성\n    - Supabase Realtime을 통해 실시간 데이터 업데이트 처리\n- **Supabase Backend**:\n    - 데이터베이스 (PostgreSQL)를 사용하여 사용자 데이터, 게임 데이터, 랭킹 정보 저장\n    - Supabase Auth를 사용하여 사용자 인증 및 권한 관리\n    - Supabase Realtime을 사용하여 실시간 데이터 업데이트 및 푸시 알림 제공\n    - PUBG API로부터 게임 데이터 수집 및 처리\n- **PUBG API**:\n    - PUBG 게임 데이터를 제공\n    - 사용자 통계, 매치 결과 등 다양한 정보 제공\n    - Supabase Backend에서 API를 호출하여 데이터 수집\n- **Anti-Cheat System**:\n    - 게임 데이터 분석 및 이상 행위 감지를 통해 부정 행위 방지\n    - 사용자 클라이언트에서 실행되는 별도의 모듈로 구현\n    - 필요에 따라 서버 측 검증 로직 추가\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Electron Application] --> B[Supabase Backend]\n    B --> C[PostgreSQL Database]\n    B --> D[PUBG API]\n    A --> E[Anti-Cheat System]\n```\n\n- **Electron Application**: 사용자의 요청을 받아 Supabase Backend로 전달하고, 응답받은 데이터를 UI에 표시합니다. Supabase Realtime을 통해 실시간 데이터 업데이트를 수신합니다.\n- **Supabase Backend**: Electron Application으로부터 받은 요청을 처리하고, PostgreSQL Database에 데이터를 저장하거나 PUBG API로부터 게임 데이터를 수집합니다. Anti-Cheat System으로부터 받은 정보를 기반으로 사용자 제재를 수행합니다.\n- **PostgreSQL Database**: 사용자 데이터, 게임 데이터, 랭킹 정보 등 플랫폼에서 사용되는 모든 데이터를 저장합니다.\n- **PUBG API**: Supabase Backend에 게임 데이터를 제공합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **도메인 분리**: 사용자 관리, 게임 관리, 랭킹 관리 등 비즈니스 도메인별로 코드를 분리합니다.\n- **계층형 아키텍처**: 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층, 인프라 계층으로 분리합니다.\n- **기능 기반 모듈**: 관련 기능을 함께 그룹화합니다 (예: 사용자 인증 모듈, 게임 로직 모듈).\n- **공유 컴포넌트**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 전용 공유 모듈에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── src/\n│   ├── components/          # 재사용 가능한 UI 컴포넌트\n│   │   ├── common/           # 공통 컴포넌트\n│   │   ├── game/             # 게임 관련 컴포넌트\n│   │   ├── user/             # 사용자 관련 컴포넌트\n│   │   └── ...\n│   ├── pages/               # 라우팅되는 페이지 컴포넌트\n│   │   ├── home/             # 홈 페이지\n│   │   ├── game/             # 게임 페이지\n│   │   ├── profile/          # 프로필 페이지\n│   │   └── ...\n│   ├── services/            # API 호출 및 데이터 처리 로직\n│   │   ├── pubgApi.ts        # PUBG API 관련 서비스\n│   │   ├── supabase.ts       # Supabase 관련 서비스\n│   │   └── ...\n│   ├── utils/               # 유틸리티 함수 및 상수\n│   │   ├── helpers.ts        # 헬퍼 함수\n│   │   ├── constants.ts      # 상수\n│   │   └── ...\n│   ├── types/               # TypeScript 타입 정의\n│   │   ├── game.ts           # 게임 관련 타입\n│   │   ├── user.ts           # 사용자 관련 타입\n│   │   └── ...\n│   ├── App.tsx              # 루트 컴포넌트\n│   ├── index.tsx            # 진입점\n│   └── ...\n├── public/              # 정적 파일 (이미지, 아이콘 등)\n├── electron/            # Electron 관련 파일\n│   ├── main.ts           # Electron 메인 프로세스\n│   ├── preload.ts        # Electron 프리로드 스크립트\n│   └── ...\n├── package.json           # 프로젝트 설정 파일\n├── tsconfig.json        # TypeScript 설정 파일\n├── tailwind.config.js   # Tailwind CSS 설정 파일\n└── ...\n```\n\n### Data Flow & Communication Patterns\n- **클라이언트-서버 통신**: API 요청/응답 패턴 (RESTful API)\n- **데이터베이스 상호 작용**: Supabase ORM을 사용하여 데이터베이스와 상호 작용\n- **외부 서비스 통합**: PUBG API를 사용하여 게임 데이터 수집\n- **실시간 통신**: Supabase Realtime을 사용하여 실시간 데이터 업데이트 및 푸시 알림\n- **데이터 동기화**: 분산된 컴포넌트 간의 데이터 일관성 유지\n\n## 4. Performance & Optimization Strategy\n\n- **코드 최적화**: 불필요한 렌더링 방지, 메모리 누수 방지, 효율적인 알고리즘 사용\n- **이미지 최적화**: 이미지 압축, Lazy Loading을 통해 초기 로딩 속도 향상\n- **캐싱**: 자주 사용되는 데이터를 캐싱하여 데이터 접근 속도 향상\n- **데이터베이스 쿼리 최적화**: 인덱스 사용, 불필요한 데이터 조회 방지\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP 구현)\n- **핵심 인프라**: 기본 시스템 설정 및 기반 컴포넌트 구축\n    - Electron 프로젝트 설정\n    - Supabase 프로젝트 설정 및 데이터베이스 스키마 정의\n    - 사용자 인증 시스템 구축 (Supabase Auth)\n- **필수 기능**: 최소 실행 가능 제품 기능\n    - 사용자 등록, 로그인, 프로필 관리 기능 구현\n    - 게임 방 생성 및 참여 기능 구현\n    - PUBG API 연동 및 게임 데이터 수집 기능 구현\n- **기본 보안**: 기본적인 보안 구현\n    - 사용자 비밀번호 암호화\n    - API 요청에 대한 인증 및 권한 부여\n- **개발 환경 설정**: 개발 환경 및 CI/CD 기본 설정\n    - 개발 환경 설정 (Node.js, npm, VS Code)\n    - Git 저장소 설정 및 코드 관리\n- **타임라인**: 예상 완료 기간 (4주)\n\n### Phase 2: Feature Enhancement\n- **고급 기능**: MVP 이상의 확장된 기능\n    - 미니 게임 구현 (킬 레이스, 생존 챌린지, 정확도 테스트)\n    - 랭킹 시스템 구현\n    - 리더보드 구현\n    - 매치메이킹 시스템 구현\n- **성능 최적화**: 시스템 성능 개선\n    - 코드 최적화\n    - 이미지 최적화\n    - 데이터베이스 쿼리 최적화\n- **향상된 보안**: 고급 보안 기능 및 규정 준수\n    - 안티 치트 시스템 구현\n    - 데이터 보안 강화\n- **모니터링 구현**: 종합적인 관찰 가능성 설정\n    - 로그 수집 및 분석 시스템 구축\n    - 성능 모니터링 시스템 구축\n- **타임라인**: 예상 완료 기간 (8주)\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **기술적 위험**: 잠재적인 기술적 문제 및 복잡성 문제\n    - PUBG API의 불안정성\n    - Electron 프레임워크의 제한 사항\n    - Supabase 서비스의 장애\n- **성능 위험**: 확장성 및 성능 병목 현상 문제\n    - 대규모 사용자 트래픽 처리\n    - 실시간 데이터 처리 성능\n- **보안 위험**: 잠재적인 보안 취약점 및 공격 벡터\n    - 사용자 데이터 유출\n    - 서비스 거부 공격 (DDoS)\n    - 게임 클라이언트 변조\n- **통합 위험**: 타사 서비스 종속성 및 실패 지점\n    - PUBG API 장애\n    - Supabase 서비스 장애\n- **완화 전략**: 식별된 각 위험을 해결하기 위한 구체적인 접근 방식\n    - PUBG API 장애에 대비한 대체 API 사용 또는 데이터 캐싱\n    - Electron 프레임워크의 제한 사항을 해결하기 위한 네이티브 모듈 사용\n    - Supabase 서비스 장애에 대비한 백업 시스템 구축\n    - 대규모 사용자 트래픽 처리를 위한 로드 밸런싱 및 캐싱\n    - 실시간 데이터 처리 성능 향상을 위한 코드 최적화 및 분산 처리\n    - 사용자 데이터 유출 방지를 위한 데이터 암호화 및 접근 제어\n    - 서비스 거부 공격 (DDoS) 방어를 위한 방화벽 및 트래픽 필터링\n    - 게임 클라이언트 변조 방지를 위한 안티 치트 시스템 구현\n\n### Project Delivery Risks\n- **타임라인 위험**: 개발 일정 문제 및 종속성\n    - 개발 일정 지연\n    - 리소스 부족\n- **리소스 위험**: 팀 역량 및 기술 전문 지식 요구 사항\n    - 개발 인력 부족\n    - 기술 숙련도 부족\n- **품질 위험**: 코드 품질 및 테스트 범위 문제\n    - 코드 품질 저하\n    - 테스트 부족\n- **배포 위험**: 프로덕션 배포 및 환경 문제\n    - 배포 환경 문제\n    - 배포 실패\n- **비상 계획**: 대체 접근 방식 및 백업 전략\n    - 개발 일정 지연에 대비한 추가 인력 투입 또는 기능 축소\n    - 리소스 부족에 대비한 외부 전문가 활용 또는 교육\n    - 코드 품질 저하 방지를 위한 코드 리뷰 및 테스트 강화\n    - 배포 환경 문제에 대비한 사전 테스트 및 배포 자동화\n",
      "writedAt": "2026-01-06T05:10:30.097Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# Project Code Guidelines\n\n## 1. Project Overview\n\nThis document outlines the coding standards and best practices for the PUBG Competitive Platform desktop application. This application is built using Electron, TypeScript, React, Tailwind CSS, Shadcn UI, and Supabase. The primary goal is to ensure code consistency, maintainability, and scalability across the project. The architecture follows a domain-driven, layered approach, separating concerns into presentation, business logic, data access, and infrastructure layers.\n\n## 2. Core Principles\n\n*   **Maintainability:** Write code that is easy to understand, modify, and extend by others.\n*   **Readability:** Prioritize clear and concise code that is well-documented.\n*   **Testability:** Design code that is easily testable with unit and integration tests.\n*   **Performance:** Optimize code for speed and efficiency without sacrificing readability.\n*   **Security:** Implement security best practices to protect user data and prevent vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript\n\n#### File Organization and Directory Structure\n\n*   Follow the universal file and folder structure outlined in the TRD.\n*   Group related files within domain-specific directories.\n*   Use descriptive and consistent file names.\n\n    ```\n    src/\n    ├── components/\n    │   ├── common/\n    │   │   ├── Button.tsx\n    │   │   ├── Input.tsx\n    │   │   └── ...\n    │   ├── game/\n    │   │   ├── GameCard.tsx\n    │   │   └── ...\n    ├── services/\n    │   ├── pubgApi.ts\n    │   ├── supabase.ts\n    │   └── ...\n    ├── types/\n    │   ├── game.ts\n    │   ├── user.ts\n    │   └── ...\n    ```\n\n#### Import/Dependency Management\n\n*   Use absolute imports for internal modules to improve readability and prevent issues with relative paths.\n*   Group imports by source (e.g., external libraries, internal modules).\n*   Avoid circular dependencies.\n*   Declare all dependencies in `package.json`.\n\n    ```typescript\n    // MUST: Absolute imports\n    import { Button } from '@/components/common/Button';\n\n    // MUST NOT: Relative imports (avoid these)\n    // import { Button } from '../../components/common/Button';\n    ```\n\n#### Error Handling Patterns\n\n*   Use `try...catch` blocks for handling synchronous errors.\n*   Use `async/await` with `try...catch` for handling asynchronous errors.\n*   Create custom error classes for specific error scenarios.\n*   Log errors with sufficient context for debugging.\n\n    ```typescript\n    // MUST: Asynchronous error handling\n    async function fetchData() {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n      } catch (error: any) {\n        console.error('Error fetching data:', error.message);\n        throw error; // Re-throw or handle as appropriate\n      }\n    }\n    ```\n\n### 3.2 React\n\n#### Component Structure\n\n*   Use functional components with hooks for state management and side effects.\n*   Keep components small and focused on a single responsibility.\n*   Use prop types to define the expected props for each component.\n*   Separate UI logic from data fetching and processing logic.\n\n    ```typescript\n    // MUST: Functional component with hooks\n    import React, { useState } from 'react';\n\n    interface MyComponentProps {\n      name: string;\n    }\n\n    const MyComponent: React.FC<MyComponentProps> = ({ name }) => {\n      const [count, setCount] = useState(0);\n\n      return (\n        <div>\n          <p>Hello, {name}!</p>\n          <button onClick={() => setCount(count + 1)}>Increment</button>\n        </div>\n      );\n    };\n\n    export default MyComponent;\n    ```\n\n#### State Management\n\n*   Use React Context for global state management.\n*   Consider using a state management library like Zustand or Jotai for complex state requirements.\n*   Avoid unnecessary re-renders by using `React.memo` or `useMemo`.\n\n    ```typescript\n    // MUST: Using React Context\n    import React, { createContext, useContext, useState } from 'react';\n\n    interface AuthContextType {\n      user: any | null;\n      login: (userData: any) => void;\n      logout: () => void;\n    }\n\n    const AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n    export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n      const [user, setUser] = useState<any | null>(null);\n\n      const login = (userData: any) => {\n        setUser(userData);\n      };\n\n      const logout = () => {\n        setUser(null);\n      };\n\n      const value: AuthContextType = {\n        user,\n        login,\n        logout,\n      };\n\n      return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n    };\n\n    export const useAuth = () => {\n      const context = useContext(AuthContext);\n      if (!context) {\n        throw new Error('useAuth must be used within an AuthProvider');\n      }\n      return context;\n    };\n    ```\n\n#### Data Fetching\n\n*   Use `useEffect` hook for data fetching in functional components.\n*   Create custom hooks for reusable data fetching logic.\n*   Handle loading and error states appropriately.\n\n    ```typescript\n    // MUST: Custom hook for data fetching\n    import { useState, useEffect } from 'react';\n\n    function useData<T>(url: string): { data: T | null; loading: boolean; error: Error | null } {\n      const [data, setData] = useState<T | null>(null);\n      const [loading, setLoading] = useState(true);\n      const [error, setError] = useState<Error | null>(null);\n\n      useEffect(() => {\n        async function fetchData() {\n          try {\n            const response = await fetch(url);\n            if (!response.ok) {\n              throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const result: T = await response.json();\n            setData(result);\n          } catch (e: any) {\n            setError(e);\n          } finally {\n            setLoading(false);\n          }\n        }\n\n        fetchData();\n      }, [url]);\n\n      return { data, loading, error };\n    }\n\n    export default useData;\n    ```\n\n### 3.3 Electron\n\n#### Main Process\n\n*   Keep the main process lean and focused on window management and inter-process communication.\n*   Delegate complex logic to renderer processes or background services.\n*   Handle application lifecycle events (e.g., `ready`, `window-all-closed`) appropriately.\n\n#### Renderer Process\n\n*   Follow React best practices for UI development.\n*   Use `ipcRenderer` for communication with the main process.\n*   Isolate sensitive logic from the renderer process.\n\n#### Inter-Process Communication (IPC)\n\n*   Use `ipcRenderer.invoke` for synchronous communication and `ipcRenderer.send` for asynchronous communication.\n*   Define clear message channels and data structures for IPC.\n*   Handle errors and exceptions in both the main and renderer processes.\n\n    ```typescript\n    // MUST: IPC Communication (Main Process)\n    import { ipcMain } from 'electron';\n\n    ipcMain.handle('get-app-version', async () => {\n      return app.getVersion();\n    });\n\n    // MUST: IPC Communication (Renderer Process)\n    import { ipcRenderer } from 'electron';\n\n    async function getAppVersion() {\n      const version = await ipcRenderer.invoke('get-app-version');\n      console.log(version);\n    }\n    ```\n\n### 3.4 Supabase\n\n#### Database Interactions\n\n*   Use the Supabase client library for database interactions.\n*   Follow best practices for SQL queries to optimize performance.\n*   Use row-level security (RLS) to control data access.\n\n#### Authentication\n\n*   Use Supabase Auth for user authentication and authorization.\n*   Implement proper session management and token handling.\n*   Protect sensitive data with encryption.\n\n#### Realtime\n\n*   Use Supabase Realtime for real-time data updates.\n*   Handle events and updates efficiently.\n*   Implement proper error handling and reconnection logic.\n\n    ```typescript\n    // MUST: Supabase Realtime example\n    import { createClient } from '@supabase/supabase-js';\n\n    const supabaseUrl = 'YOUR_SUPABASE_URL';\n    const supabaseKey = 'YOUR_SUPABASE_ANON_KEY';\n    const supabase = createClient(supabaseUrl, supabaseKey);\n\n    supabase\n      .channel('any_name')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'your_table' },\n        (payload) => {\n          console.log('Change received!', payload);\n        }\n      )\n      .subscribe();\n    ```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Naming Conventions:**\n    *   Variables: `camelCase`\n    *   Functions: `camelCase`\n    *   Classes: `PascalCase`\n    *   Interfaces: `PascalCase` (prefix with `I` if necessary to avoid naming conflicts)\n    *   Constants: `UPPER_SNAKE_CASE`\n    *   Components: `PascalCase`\n    *   Files: `camelCase.ts` or `PascalCase.tsx`\n    *   Rationale: Consistent naming improves code readability and maintainability.\n*   **Indentation:** Use 2 spaces for indentation.\n    *   Rationale: Consistent indentation makes code easier to read and understand.\n*   **Line Length:** Limit lines to 120 characters.\n    *   Rationale: Shorter lines improve readability and prevent horizontal scrolling.\n*   **Comments:** Write clear and concise comments to explain complex logic.\n    *   Rationale: Comments help developers understand the purpose and functionality of code.\n*   **Error Handling:** Implement proper error handling to prevent application crashes.\n    *   Rationale: Robust error handling improves application stability and user experience.\n*   **Code Formatting:** Use Prettier to automatically format code.\n    *   Rationale: Consistent formatting reduces code review time and improves code quality.\n*   **Type Annotations:** Use explicit type annotations for all variables, function parameters, and return types.\n    *   Rationale: TypeScript's type system helps catch errors early and improves code maintainability.\n*   **Avoid `any` Type:** Minimize the use of the `any` type. Use more specific types whenever possible.\n    *   Rationale: Using specific types improves type safety and reduces the risk of runtime errors.\n*   **Use ESLint:** Configure and use ESLint to enforce coding standards and identify potential issues.\n    *   Rationale: ESLint helps maintain code quality and consistency across the project.\n*   **Use Strict Mode:** Enable TypeScript's strict mode to catch potential errors and enforce best practices.\n    *   Rationale: Strict mode improves code safety and reduces the risk of runtime errors.\n*   **Use Async/Await:** Prefer `async/await` over callbacks for asynchronous operations.\n    *   Rationale: `async/await` makes asynchronous code easier to read and understand.\n*   **Immutable Data:** Use immutable data structures whenever possible.\n    *   Rationale: Immutable data structures prevent accidental modifications and simplify state management.\n*   **Destructuring:** Use destructuring to extract values from objects and arrays.\n    *   Rationale: Destructuring makes code more concise and readable.\n\n    ```typescript\n    // MUST: Destructuring example\n    const user = {\n      firstName: 'John',\n      lastName: 'Doe',\n      age: 30,\n    };\n\n    const { firstName, lastName } = user;\n    console.log(firstName, lastName); // John Doe\n    ```\n\n*   **Spread Operator:** Use the spread operator to create shallow copies of objects and arrays.\n    *   Rationale: The spread operator makes it easy to create new objects and arrays without modifying the original data.\n\n    ```typescript\n    // MUST: Spread operator example\n    const originalArray = [1, 2, 3];\n    const newArray = [...originalArray, 4, 5];\n    console.log(newArray); // [1, 2, 3, 4, 5]\n    ```\n\n### MUST NOT Do:\n\n*   **Global Variables:** MUST NOT use global variables.\n    *   Rationale: Global variables can lead to naming conflicts and make code harder to reason about.\n*   **Magic Numbers:** MUST NOT use magic numbers (unexplained numeric literals).\n    *   Rationale: Magic numbers make code harder to understand and maintain. Use constants instead.\n\n    ```typescript\n    // MUST NOT: Magic number\n    function calculateArea(radius: number) {\n      return 3.14 * radius * radius; // What is 3.14?\n    }\n\n    // MUST: Use constant\n    const PI = 3.14;\n    function calculateArea(radius: number) {\n      return PI * radius * radius;\n    }\n    ```\n\n*   **Nested Callbacks:** MUST NOT use deeply nested callbacks (callback hell).\n    *   Rationale: Nested callbacks make code harder to read and maintain. Use `async/await` or Promises instead.\n*   **Ignoring Errors:** MUST NOT ignore errors without handling them.\n    *   Rationale: Ignoring errors can lead to unexpected behavior and make it harder to debug issues.\n*   **Console Logs in Production:** MUST NOT leave `console.log` statements in production code.\n    *   Rationale: `console.log` statements can expose sensitive information and impact performance.\n*   **Complex Conditional Statements:** MUST NOT write overly complex conditional statements.\n    *   Rationale: Complex conditionals make code harder to read and understand. Simplify them using helper functions or switch statements.\n*   **Direct DOM Manipulation:** MUST NOT directly manipulate the DOM in React components (except when absolutely necessary).\n    *   Rationale: Direct DOM manipulation can interfere with React's virtual DOM and lead to unexpected behavior. Use React's state management and rendering mechanisms instead.\n*   **Mutating Props:** MUST NOT mutate props passed to React components.\n    *   Rationale: Mutating props can lead to unexpected behavior and make it harder to reason about component updates.\n*   **Huge components:** MUST NOT write huge, multi responsibility modules in single file.\n    *   Rationale: Huge components are harder to understand, test, and maintain. Break them down into smaller, more focused components.\n*   **Complex state management:** MUST NOT define complex state management pattern when simple state management can resolve the case.\n    *   Rationale: Overly complex state management can add unnecessary overhead and make code harder to understand. Choose the simplest state management solution that meets the requirements.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n*   **Atomic Design:** Consider using atomic design principles to structure React components (atoms, molecules, organisms, templates, pages).\n*   **Separation of Concerns:** Separate UI components from business logic and data fetching.\n*   **Single Responsibility Principle:** Each component or module should have a single, well-defined responsibility.\n\n### Data Flow Patterns\n\n*   **Unidirectional Data Flow:** Follow a unidirectional data flow pattern in React applications.\n*   **Props for Data Down, Events for Actions Up:** Pass data down to child components via props and use events to communicate actions back to parent components.\n*   **Avoid Two-Way Data Binding:** Avoid two-way data binding, as it can make it harder to reason about data flow.\n\n### State Management Conventions\n\n*   **Local State:** Use `useState` hook for component-local state.\n*   **Context API:** Use React Context for global state that is needed by multiple components.\n*   **Redux/Zustand (Optional):** Consider using Redux or Zustand for more complex state management scenarios.\n\n### API Design Standards\n\n*   **RESTful APIs:** Design APIs following RESTful principles.\n*   **JSON Data Format:** Use JSON for request and response bodies.\n*   **HTTP Status Codes:** Use appropriate HTTP status codes to indicate success or failure.\n*   **Error Handling:** Provide informative error messages in API responses.\n*   **Authentication:** Implement proper authentication and authorization mechanisms.\n```",
      "writedAt": "2026-01-06T05:10:30.097Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2026-01-06T05:10:30.097Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2026-01-06T05:10:30.097Z"
    }
  ]
}